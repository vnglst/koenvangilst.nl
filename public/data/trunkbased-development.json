{
  "title": "Why I Prefer Trunk-Based Development",
  "publishedAt": "2023-11-10",
  "image": {
    "src": "/static/images/trunkbased.jpg",
    "alt": "A picture of a tree with branches generated by DALL-E",
    "width": 1024,
    "height": 1024,
    "showAsHeader": true
  },
  "summary": "Moving away from the structured Git Flow to a more continuous approach with only one main branch.",
  "tags": [
    "article",
    "git",
    "continuous deployment",
    "trunk-based development"
  ],
  "tagsAsSlugs": [
    "article",
    "git",
    "continuous-deployment",
    "trunk-based-development"
  ],
  "slug": "trunkbased-development",
  "code": "var Component=(()=>{var m=Object.create;var r=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var a in e)r(t,a,{get:e[a],enumerable:!0})},s=(t,e,a,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of u(e))!g.call(t,i)&&i!==a&&r(t,i,{get:()=>e[i],enumerable:!(o=p(e,i))||o.enumerable});return t};var w=(t,e,a)=>(a=t!=null?m(f(t)):{},s(e||!t||!t.__esModule?r(a,\"default\",{value:t,enumerable:!0}):a,t)),v=t=>s(r({},\"__esModule\",{value:!0}),t);var c=b((x,l)=>{l.exports=_jsx_runtime});var T={};y(T,{default:()=>d,frontmatter:()=>k});var n=w(c()),k={title:\"Why I Prefer Trunk-Based Development\",publishedAt:\"2023-11-10\",image:{src:\"/static/images/trunkbased.jpg\",alt:\"A picture of a tree with branches generated by DALL-E\",width:1024,height:1024,showAsHeader:!0},summary:\"Moving away from the structured Git Flow to a more continuous approach with only one main branch.\",tags:[\"article\",\"git\",\"continuous deployment\",\"trunk-based development\"]};function h(t){let e={a:\"a\",blockquote:\"blockquote\",code:\"code\",h2:\"h2\",h3:\"h3\",li:\"li\",ol:\"ol\",p:\"p\",section:\"section\",span:\"span\",sup:\"sup\",ul:\"ul\",...t.components},{Image:a}=e;return a||I(\"Image\",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:`As someone who has been involved in web development for years, I've had my fair share of experiences with different branching strategies.\nOver time, I've grown to prefer trunk-based development (TBD) for its simplicity and alignment with continuous deployment, especially when compared to the more traditional Git Flow model.`}),`\n`,(0,n.jsxs)(e.p,{children:[\"Before delving into why I prefer this approach, let's quickly recap the main difference between TBD and Git Flow.\",(0,n.jsx)(e.sup,{children:(0,n.jsx)(e.a,{href:\"#user-content-fn-1\",id:\"user-content-fnref-1\",\"data-footnote-ref\":!0,\"aria-describedby\":\"footnote-label\",children:\"1\"})})]}),`\n`,(0,n.jsxs)(e.h2,{id:\"tbd-vs-git-flow\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#tbd-vs-git-flow\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"TBD vs. Git Flow\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Trunk-based development traditionally involves developers working directly on the main trunk branch. In contrast, the variant I advocate for utilizes short-lived feature branches for pull requests before merging them frequently back into the trunk. This variant is sometimes, confusingly, equated with \",(0,n.jsx)(e.a,{href:\"https://docs.github.com/en/get-started/quickstart/github-flow\",children:\"GitHub Flow\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Git Flow, in contrast, involves multiple branches (feature, develop, release, hotfix), each serving a specific stage in the development cycle. This model suits environments where releases are less frequent.\"}),`\n`,(0,n.jsxs)(e.h2,{id:\"appeal-of-trunk-based-development\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#appeal-of-trunk-based-development\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Appeal of trunk-based development\"]}),`\n`,(0,n.jsx)(e.p,{children:\"What draws me to TBD is its straightforward approach. Here\\u2019s why I find it effective:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"One source of truth: With only one branch that represents the latest state of the codebase, there\\u2019s no confusion about which branch is the most up-to-date.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Simplified workflow: Fewer branches translate to less complexity. It makes the workflow more manageable, especially for new team members. It also reduces the risk of merge conflicts.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Quick integration: Merging changes frequently into the trunk means you can integrate and test new features more rapidly. There's always only one version of the codebase to test & integrate with.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This is not just based on my personal experience. Nicole Forsgren notes in her book \",(0,n.jsx)(e.a,{href:\"accelerate-reading-notes\",children:\"Accelerate: The Science of Lean Software and DevOps\"}),\" that teams do better in terms of deployment frequency, lead time, and mean time to recovery.\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Our research also found that developing off trunk/master rather than on long-lived feature branches was correlated with higher delivery performance. Teams that did well had fewer than three active branches at any time, their branches had very short lifetimes (less than a day) before being merged into trunk and never had \\u201Ccode freeze\\u201D or stabilization periods. It\\u2019s worth re-emphasizing that these results are independent of team size, organization size, or industry.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.h2,{id:\"overcoming-resistance\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#overcoming-resistance\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Overcoming resistance\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Initially, I was hesitant about trunk-based development (TBD), finding it disruptive to my usual workflow which involved aligning branches with specific environments. However, after our tech lead introduced it and we began working in this new way, my perspective shifted. I quickly recognized the benefits, such as reduced complexity and faster processes, that came from moving away from multiple long-lived branches.\"}),`\n`,(0,n.jsx)(e.p,{children:\"At first, our team was scared by the fact that every pull request we merged automatically landed on the main branch and that our tech lead said we had to make sure the code was always in a releasable state. This was a stark departure from the safety net we felt with Git Flow, where multiple branches provided a cushion before hitting production. The notion of having every change be potentially release-ready brought a new level of accountability and focus to our work.\"}),`\n`,(0,n.jsxs)(e.h2,{id:\"feature-toggles\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#feature-toggles\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Feature toggles\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Another thing that may seem impractical is building large features or doing complex refactors that could take weeks to complete. How is that possible with short-lived branches, while still keeping the main branch in a releasable state? The answer lies in the concept of feature toggles.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Feature toggles, also known as feature flags, let you merge partial or incomplete features into the main branch without disrupting the user experience. By wrapping new functionalities in these toggles, you deploy them turned 'off' and then activate them when ready. This approach gives you the flexibility to continuously integrate and test changes in a live environment, without exposing them to end-users prematurely.\"}),`\n`,(0,n.jsx)(e.p,{children:\"The adoption of feature toggles requires a shift in mindset. You have to plan development in a way that allows incremental changes and think ahead about how features could be toggled on and off. This planning approach aims to result in more modular and adaptable code, although achieving this can be challenging.\"}),`\n`,(0,n.jsxs)(e.h2,{id:\"immature-projects\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#immature-projects\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Immature projects\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Not every development team is at a stage where they can reliably maintain the main branch in a releasable state. Sometimes there is limited or no testing capacity, sometimes there are no automated tests yet. These shortcomings can be overcome by being pragmatic about trunk-based development (TBD). As a team, you can choose to first create a release branch from the trunk every time you're ready for a release.\"}),`\n`,(0,n.jsx)(e.p,{children:\"This approach serves as a middle ground, especially for teams in the transition phase or those still developing their testing infrastructure. By branching off a release branch, teams can have a buffer zone for final testing and polishing without compromising the main branch's integrity. This step provides a safety net for performing additional checks and balances that are not yet integrated into the daily development workflow.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"It's good to take into account that any new commits should still land on the main trunk first and should then be cherry-picked to the release branch. The \",(0,n.jsx)(e.a,{href:\"https://trunkbaseddevelopment.com/\",children:\"excellent website on trunk-based development\"}),\" explains in great detail the different approaches teams can take here. This way developers can mix and match the different branching strategies depending on the maturity level of their CI/CD setup.\"]}),`\n`,(0,n.jsxs)(e.h2,{id:\"conclusion\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#conclusion\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Conclusion\"]}),`\n`,(0,n.jsx)(e.p,{children:\"In conclusion, my evolution as a web developer, from a Git Flow enthusiast to a staunch advocate of trunk-based development (TBD), has been a journey of adapting to a more dynamic and streamlined workflow. Initially hesitant, I've come to appreciate the clarity and simplicity of TBD. This shift has not only refined the development practices of the teams I was in but also instilled a mindset geared towards continuous, incremental improvement.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Trunk-based development, in my experience, represents more than just a branching strategy; it's a reflection of a modern, responsive approach to software development.\"}),`\n`,(0,n.jsxs)(e.h2,{id:\"summary-of-pros-and-cons\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#summary-of-pros-and-cons\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Summary of Pros and Cons\"]}),`\n`,(0,n.jsxs)(e.h3,{id:\"pros\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#pros\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Pros\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Simplified Workflow\"}),`\n`,(0,n.jsx)(e.li,{children:\"Quicker Integration\"}),`\n`,(0,n.jsx)(e.li,{children:\"Single Source of Truth\"}),`\n`,(0,n.jsx)(e.li,{children:\"Aligns well with continuous deployment\"}),`\n`]}),`\n`,(0,n.jsxs)(e.h3,{id:\"cons\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#cons\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Cons\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Requires strong CI/CD infrastructure\"}),`\n`,(0,n.jsx)(e.li,{children:\"Requires a cultural shift\"}),`\n`,(0,n.jsx)(e.li,{children:\"Feature toggles can be challenging to implement\"}),`\n`]}),`\n`,(0,n.jsxs)(e.h2,{id:\"some-practical-examples\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#some-practical-examples\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Some practical examples\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Developing new features on short-lived feature branches could work like this:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"git checkout -b \",(0,n.jsx)(e.code,{children:\"feature/abc\"})]}),`\n`,(0,n.jsx)(e.li,{children:\"create a PR for review\"}),`\n`,(0,n.jsx)(e.li,{children:\"make sure all code is in a releasable state\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"merge to \",(0,n.jsx)(e.code,{children:\"main\"}),\" \\u2192 deployment to development\"]}),`\n`]}),`\n`,(0,n.jsx)(a,{src:\"/static/images/mermaid1.svg\",width:\"830\",height:\"500\",alt:\"mermaid diagram of trunk-based development\"}),`\n`,`\n`,(0,n.jsxs)(e.h3,{id:\"deploying-a-new-release\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#deploying-a-new-release\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Deploying a new release\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Ideally, the deployment process is fully automated in a CI/CD pipeline. It would then be a matter of automatically deploying the latest main to production regularly.\"}),`\n`,(0,n.jsx)(e.p,{children:\"In the early phases of a project, this might not be the case yet. In that case, you could opt for using release branches like this:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"create a branch on remote \",(0,n.jsx)(e.code,{children:\"release/2022-09-22\"})]}),`\n`,(0,n.jsx)(e.li,{children:\"CI/CD triggers deploy to acceptance\"}),`\n`,(0,n.jsx)(e.li,{children:\"tag commit on the release branch \\u2192 deployment to production\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"In a diagram this would look like:\"}),`\n`,(0,n.jsx)(a,{src:\"/static/images/mermaid2.svg\",width:\"830\",height:\"500\",alt:\"mermaid diagram of trunk-based development\"}),`\n`,`\n`,(0,n.jsxs)(e.section,{\"data-footnotes\":!0,className:\"footnotes\",children:[(0,n.jsxs)(e.h2,{className:\"sr-only\",id:\"footnote-label\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#footnote-label\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Footnotes\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{id:\"user-content-fn-1\",children:[`\n`,(0,n.jsxs)(e.p,{children:[\"The concept of Git Flow was originally introduced in the blog post \",(0,n.jsx)(e.a,{href:\"https://nvie.com/posts/a-successful-git-branching-model/\",children:\"A successful Git branching model\"}),\" by Vincent Driessen. His diagram of Git Flow has since then been shared countless times with many teams and on many corporate websites. In 2020 Vincent added a comment that Git Flow is not for everyone, especially when a team is doing continuous deployment. \",(0,n.jsx)(e.a,{href:\"#user-content-fnref-1\",\"data-footnote-backref\":\"\",\"aria-label\":\"Back to reference 1\",className:\"data-footnote-backref\",children:\"\\u21A9\"})]}),`\n`]}),`\n`]}),`\n`]})]})}function d(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(h,{...t})}):h(t)}function I(t,e){throw new Error(\"Expected \"+(e?\"component\":\"object\")+\" `\"+t+\"` to be defined: you likely forgot to import, pass, or provide it.\")}return v(T);})();\n;return Component;",
  "readingTime": {
    "text": "7 min read",
    "minutes": 6.83,
    "time": 409800,
    "words": 1366
  }
}
{
  "title": "One command to run it all",
  "publishedAt": "2021-12-10",
  "summary": "Why mocking all external requests for your app is worth it.",
  "tags": [
    "article",
    "javascript",
    "react",
    "testing"
  ],
  "tagsAsSlugs": [
    "article",
    "javascript",
    "react",
    "testing"
  ],
  "slug": "one-script-to-run-it-all",
  "code": "var Component=(()=>{var m=Object.create;var a=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var o in e)a(t,o,{get:e[o],enumerable:!0})},i=(t,e,o,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of u(e))!f.call(t,r)&&r!==o&&a(t,r,{get:()=>e[r],enumerable:!(s=p(e,r))||s.enumerable});return t};var v=(t,e,o)=>(o=t!=null?m(g(t)):{},i(e||!t||!t.__esModule?a(o,\"default\",{value:t,enumerable:!0}):o,t)),w=t=>i(a({},\"__esModule\",{value:!0}),t);var h=y((I,c)=>{c.exports=_jsx_runtime});var x={};b(x,{default:()=>d,frontmatter:()=>k});var n=v(h()),k={title:\"One command to run it all\",publishedAt:\"2021-12-10\",summary:\"Why mocking all external requests for your app is worth it.\",tags:[\"article\",\"javascript\",\"react\",\"testing\"]};function l(t){let e={a:\"a\",code:\"code\",p:\"p\",pre:\"pre\",span:\"span\",...t.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"One of the more annoying things I've experienced as a front-end developer in complex corporate environments is that it's often surprisingly hard to get the app to start. APIs might not be available, have no access because of proxies, you need a plugin etc. etc.\"}),`\n`,(0,n.jsx)(e.p,{children:\"To avoid this frustration on my most recent project I've started with a script that allows me to always (in any environment, even without an internet connection!) start the app using one command:\"}),`\n`,(0,n.jsx)(e.pre,{className:\"language-bash\",children:(0,n.jsx)(e.code,{className:\"language-bash code-highlight\",children:(0,n.jsxs)(e.span,{className:\"code-line\",children:[(0,n.jsx)(e.span,{className:\"token function\",children:\"yarn\"}),` start:mocked\n`]})})}),`\n`,(0,n.jsx)(e.p,{children:\"This requires mocking the external services (APIs, authentication) which are more work. But I'm 100% sure this has paid itself off many times over.\"}),`\n`,(0,n.jsx)(e.p,{children:\"These mocks can also be reused for integration tests. This gives me a lot more confidence when doing large-scale refactors or deploying new features. Another benefit of this approach: When tests do fail I can just start the mocked version of the app to see why the tests are failing (in the browser). No more debugging endless streams of Jest error logs.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"To mock API calls in both the browser and in tests I've used a library called Mock Service Worker and a custom mock for the Microsoft Authentication Library. Both are a bit tricky to set up, but the MSW library is \",(0,n.jsx)(e.a,{href:\"https://mswjs.io/\",children:\"well-documented\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"And about mocking the Microsoft Authentication Library I'll write soon, it's easier than you'd think.\"})]})}function d(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(l,{...t})}):l(t)}return w(x);})();\n;return Component;",
  "readingTime": {
    "text": "2 min read",
    "minutes": 1.125,
    "time": 67500,
    "words": 225
  }
}
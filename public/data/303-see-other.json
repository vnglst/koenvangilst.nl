{
  "title": "303 See Other",
  "publishedAt": "2019-08-25",
  "summary": "Last week I learned a few things about how redirects and 303 status codes are handled in the browser.",
  "tags": [
    "article",
    "restful",
    "http"
  ],
  "tagsAsSlugs": [
    "article",
    "restful",
    "http"
  ],
  "slug": "303-see-other",
  "code": "var Component=(()=>{var p=Object.create;var o=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var k=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var N=(s,e)=>()=>(e||s((e={exports:{}}).exports,e),e.exports),w=(s,e)=>{for(var a in e)o(s,a,{get:e[a],enumerable:!0})},c=(s,e,a,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of m(e))!g.call(s,t)&&t!==a&&o(s,t,{get:()=>e[t],enumerable:!(r=u(e,t))||r.enumerable});return s};var f=(s,e,a)=>(a=s!=null?p(k(s)):{},c(e||!s||!s.__esModule?o(a,\"default\",{value:s,enumerable:!0}):a,s)),y=s=>c(o({},\"__esModule\",{value:!0}),s);var l=N((T,i)=>{i.exports=_jsx_runtime});var I={};w(I,{default:()=>d,frontmatter:()=>b});var n=f(l()),b={title:\"303 See Other\",publishedAt:\"2019-08-25\",summary:\"Last week I learned a few things about how redirects and 303 status codes are handled in the browser.\",tags:[\"article\",\"restful\",\"http\"]};function h(s){let e={a:\"a\",code:\"code\",em:\"em\",p:\"p\",pre:\"pre\",span:\"span\",...s.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"Last week I learned a few things about how redirects and 303 status codes are handled in the browser.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the app I'm building the following happens: Once a session expires any requests to the server are blocked and redirected to the URL of the login (HTML) webpage. This also happens for any fetch requests (ajax calls) our single-page app is making. My job this week was to handle these redirects gracefully and show users some \",(0,n.jsx)(e.em,{children:\"Hello, your session has expired please login again\"}),\" page. This turned out to be more challenging than I anticipated.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"I probably should have known, but 303 status codes are not visible on the client (i.e. in my JavaScript code). So my plan to just check for any 303s and redirect based on that didn\\u2019t pan out. The only errors I was seeing, were CORS errors since the login page is outside our domain.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"My next strategy was to use the \",(0,n.jsx)(e.code,{children:\"redirect: \\u2018error\\u2019\"}),\" option that the fetch API provides, like so:\"]}),`\n`,(0,n.jsx)(e.pre,{className:\"language-js\",children:(0,n.jsxs)(e.code,{className:\"language-js code-highlight\",children:[(0,n.jsxs)(e.span,{className:\"code-line\",children:[(0,n.jsx)(e.span,{className:\"token function\",children:\"fetch\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\"(\"}),(0,n.jsx)(e.span,{className:\"token string\",children:\"'https://httpstat.us/303'\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\",\"}),\" \",(0,n.jsx)(e.span,{className:\"token punctuation\",children:\"{\"}),\" \",(0,n.jsx)(e.span,{className:\"token literal-property property\",children:\"redirect\"}),(0,n.jsx)(e.span,{className:\"token operator\",children:\":\"}),\" \\u201Cerror\\u201D \",(0,n.jsx)(e.span,{className:\"token punctuation\",children:\"}\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\")\"}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"    \",(0,n.jsx)(e.span,{className:\"token punctuation\",children:\".\"}),(0,n.jsx)(e.span,{className:\"token method function property-access\",children:\"then\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\"(\"}),(0,n.jsx)(e.span,{className:\"token console class-name\",children:\"console\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\".\"}),(0,n.jsx)(e.span,{className:\"token property-access\",children:\"log\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\")\"}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"    \",(0,n.jsx)(e.span,{className:\"token punctuation\",children:\".\"}),(0,n.jsx)(e.span,{className:\"token keyword control-flow\",children:\"catch\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\"(\"}),(0,n.jsx)(e.span,{className:\"token console class-name\",children:\"console\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\".\"}),(0,n.jsx)(e.span,{className:\"token property-access\",children:\"error\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\")\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\";\"}),`\n`]})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"In Chrome this request fails with a \",(0,n.jsx)(e.code,{children:\"TypeError: Failed to fetch\"}),\". Could I use this error to detect expired sessions? In Firefox I got the same error message. Hurrah!?\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"However, on Safari I got \",(0,n.jsx)(e.code,{children:\"TypeError: Not allowed to follow a redirection while loading https://httpstat.us/303\"}),\". That's more informative, but in general, I got a bad feeling about this approach: The error messages were not consistent across browsers and the \",(0,n.jsx)(e.code,{children:\"Failed to fetch\"}),\" on Chrome could be any kind of failure. I could not be sure these failures were related to redirects (and thus expired user sessions).\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"My final approach was based on using the \",(0,n.jsx)(e.code,{children:\"manual\"}),\" redirect Enum. That gave me a little bit more information on modern browsers:\"]}),`\n`,(0,n.jsx)(e.pre,{className:\"language-js\",children:(0,n.jsxs)(e.code,{className:\"language-js code-highlight\",children:[(0,n.jsxs)(e.span,{className:\"code-line\",children:[(0,n.jsx)(e.span,{className:\"token function\",children:\"fetch\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\"(\"}),(0,n.jsx)(e.span,{className:\"token string\",children:\"'https://httpstat.us/303'\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\",\"}),\" \",(0,n.jsx)(e.span,{className:\"token punctuation\",children:\"{\"}),\" \",(0,n.jsx)(e.span,{className:\"token literal-property property\",children:\"redirect\"}),(0,n.jsx)(e.span,{className:\"token operator\",children:\":\"}),\" \",(0,n.jsx)(e.span,{className:\"token string\",children:\"'manual'\"}),\" \",(0,n.jsx)(e.span,{className:\"token punctuation\",children:\"}\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\")\"}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"  \",(0,n.jsx)(e.span,{className:\"token punctuation\",children:\".\"}),(0,n.jsx)(e.span,{className:\"token method function property-access\",children:\"then\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\"(\"}),(0,n.jsx)(e.span,{className:\"token console class-name\",children:\"console\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\".\"}),(0,n.jsx)(e.span,{className:\"token property-access\",children:\"log\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\")\"}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"  \",(0,n.jsx)(e.span,{className:\"token punctuation\",children:\".\"}),(0,n.jsx)(e.span,{className:\"token keyword control-flow\",children:\"catch\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\"(\"}),(0,n.jsx)(e.span,{className:\"token console class-name\",children:\"console\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\".\"}),(0,n.jsx)(e.span,{className:\"token property-access\",children:\"error\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\")\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\";\"}),`\n`]})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"This request results in a Response object with a \",(0,n.jsx)(e.code,{children:\"type: \\u201Copaqueredirect\\u201D\"}),\" property on all \",(0,n.jsx)(e.em,{children:\"modern\"}),\" browsers. This was something, but of course, it does not work on older browsers like \",(0,n.jsx)(e.code,{children:\"IE11\"}),\" (for which our app relies on a fetch polyfill).\"]}),`\n`,(0,n.jsx)(e.p,{children:\"So even this final approach did not give me a reliable way to detect expired sessions. As a temporary solution, it kinda works. On IE11 we're now showing users a general error message on failed requests that are missing a status code. These messages offer users a \\u201CTry to login again\\u201D link.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the meantime, other engineers are working on a solution to let the client know directly that a session has expired. If I had to choose a solution I would go for a response with status 401 (authentication is possible but has failed or was not yet been provided.). And in the response body, I would expect the reason. In \",(0,n.jsx)(e.code,{children:\"json/text\"}),\" \\u2018cause that\\u2019s what I\\u2019m requesting in my headers as the \",(0,n.jsx)(e.code,{children:\"Content-Type\"}),\". Then I can absolutely know for sure what\\u2019s going on.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"(Note: There\\u2019s also the \",(0,n.jsx)(e.code,{children:\"redirected\"}),\" property on the Response object, however, this is still an experimental feature that\\u2019s not available in all browsers, Safari and Internet Explorer being notable exceptions for my purposes. \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Response/redirected\",children:\"See the MDN page for Response\"}),\")\"]})]})}function d(s={}){let{wrapper:e}=s.components||{};return e?(0,n.jsx)(e,{...s,children:(0,n.jsx)(h,{...s})}):h(s)}return y(I);})();\n;return Component;",
  "readingTime": {
    "text": "3 min read",
    "minutes": 2.57,
    "time": 154200,
    "words": 514
  }
}
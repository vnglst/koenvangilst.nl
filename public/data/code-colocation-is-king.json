{
  "title": "Code Colocation is King",
  "publishedAt": "2021-11-14",
  "image": {
    "src": "/static/images/code-colocation.jpg",
    "alt": "A man sitting in front of a computer screen and lots of interconnected windows above him",
    "width": 1024,
    "height": 1024,
    "showAsHeader": true
  },
  "summary": "A simple principle to help structure code better",
  "tags": [
    "article",
    "software design"
  ],
  "tagsAsSlugs": [
    "article",
    "software-design"
  ],
  "slug": "code-colocation-is-king",
  "code": "var Component=(()=>{var u=Object.create;var r=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var w=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),y=(o,e)=>{for(var n in e)r(o,n,{get:e[n],enumerable:!0})},a=(o,e,n,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of f(e))!m.call(o,i)&&i!==n&&r(o,i,{get:()=>e[i],enumerable:!(s=p(e,i))||s.enumerable});return o};var b=(o,e,n)=>(n=o!=null?u(g(o)):{},a(e||!o||!o.__esModule?r(n,\"default\",{value:o,enumerable:!0}):n,o)),x=o=>a(r({},\"__esModule\",{value:!0}),o);var l=w((j,h)=>{h.exports=_jsx_runtime});var I={};y(I,{default:()=>d,frontmatter:()=>v});var t=b(l()),v={title:\"Code Colocation is King\",publishedAt:\"2021-11-14\",image:{src:\"/static/images/code-colocation.jpg\",alt:\"A man sitting in front of a computer screen and lots of interconnected windows above him\",width:1024,height:1024,showAsHeader:!0},summary:\"A simple principle to help structure code better\",tags:[\"article\",\"software design\"]};function c(o){let e={a:\"a\",blockquote:\"blockquote\",code:\"code\",li:\"li\",p:\"p\",strong:\"strong\",ul:\"ul\",...o.components},{Disclaimer:n}=e;return n||k(\"Disclaimer\",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"One of the things I struggled with when I started as a programmer was where to put my code. It was not something I could easily find in tutorials, and for a long time, I wondered why everyone was so focused on how to get framework X to do Y when all I wanted to know was where to put the code that does Y.\"}),`\n`,(0,t.jsx)(e.p,{children:`Turns out that \"where to put code\" is one of the hard things in software engineering, and there are no silver bullets. That's part of the reason why there are so few easy tutorials on this subject.`}),`\n`,(0,t.jsxs)(e.p,{children:[\"Most of the code structuring patterns out there (the MVC pattern or patterns recommended by libraries) make sense in their way, but they often fail to tell you what to do in day-to-day cases. For instance, when you have a simple utility function that's only used in one place, where should you put it? In the global \",(0,t.jsx)(e.code,{children:\"/utils\"}),\" folder?\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Over the years, I've learned that the following principle helps to structure code in a way that's easy to understand and maintain: \",(0,t.jsx)(e.strong,{children:\"keep the code that changes together close together\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"This means that if you have a helper function that's specific to the feature you're writing in \",(0,t.jsx)(e.code,{children:\"featureA/Table.tsx\"}),\", it's a good idea to keep this function close at hand. So put it either inside the \",(0,t.jsx)(e.code,{children:\"Table.tsx\"}),\" file or right next to it if you have several helper functions. This way, when you have to change or understand the functionality of featureA, all the code you need is close by.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"For this blog post, I've chosen \",(0,t.jsx)(e.strong,{children:\"Code Colocation is King\"}),\" as a title, but it's more often called \",(0,t.jsx)(e.strong,{children:\"the principle of proximity\"}),\":\"]}),`\n`,(0,t.jsxs)(e.blockquote,{children:[`\n`,(0,t.jsx)(e.p,{children:\"The principle of proximity focuses on how well organized your code is with respect to readability and change. Proximity implies that functions that are changed together are moved closer together. Proximity is both a design principle and a heuristic for refactoring hotspots toward code that's easier to understand.\"}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"\\u2014 \",(0,t.jsx)(e.a,{href:\"https://pragprog.com/titles/atevol/software-design-x-rays/\",children:\"Software Design X-Rays by Adam Tornhill\"})]}),`\n`,(0,t.jsx)(e.p,{children:\"So think about the Proximity Principle the next time you're in doubt:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"whether it makes sense to move a function to the global \",(0,t.jsx)(e.code,{children:\"helpers\"}),\" folder\"]}),`\n`,(0,t.jsx)(e.li,{children:\"where the tests of the component you've just written should live\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"whether component styling should be in a global \",(0,t.jsx)(e.code,{children:\"/styles\"}),\" folder, or next to the implementation\"]}),`\n`,(0,t.jsx)(e.li,{children:\"if the code that manages state should be moved to a separate file with all the other state updates\"}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"Like I said at the beginning of this post: There are no silver bullets for structuring code. And the proximity principle does not always tell you exactly where to put code. But when you're in doubt, it tells you to keep code close to where it's relevant -- until you've found a good reason not to do so anymore.\"}),`\n`,(0,t.jsx)(n,{children:(0,t.jsxs)(e.p,{children:[`This article reached the Hacker News front page on Feb. 3rd 2022. It got a lot\nof good feedback there and I'd like to revisit this theme in a future post.\nUntil then be sure to `,(0,t.jsx)(e.a,{href:\"https://news.ycombinator.com/item?id=30166318\",children:`head over to the discussion on Hacker\nNews`}),` for some interesting\ncomments.`]})})]})}function d(o={}){let{wrapper:e}=o.components||{};return e?(0,t.jsx)(e,{...o,children:(0,t.jsx)(c,{...o})}):c(o)}function k(o,e){throw new Error(\"Expected \"+(e?\"component\":\"object\")+\" `\"+o+\"` to be defined: you likely forgot to import, pass, or provide it.\")}return x(I);})();\n;return Component;",
  "readingTime": {
    "text": "3 min read",
    "minutes": 2.605,
    "time": 156300,
    "words": 521
  }
}